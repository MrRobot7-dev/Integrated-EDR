from flask import Flask, render_template, request, jsonify
import pandas as pd
import numpy as np
from tensorflow import keras
import os
import logging
from datetime import datetime
import requests
import time

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev_key_for_development')

# Global variables
model = None
test_data = None
X = None
y = None

# VirusTotal API configuration
VT_API_KEY = "06c0f1b6b94125d631c85587f43b01de1e6c5bf3ed0e45d42984bc6b00adf2b7"
VT_API_URL = "https://www.virustotal.com/vtapi/v2/file/report"

def load_model():
    """Load the pre-trained model"""
    global model
    try:
        model_path = os.path.join(os.path.dirname(__file__), 'model', 'model.h5')
        model = keras.models.load_model(model_path)
        logger.info("Model loaded successfully")
        return True
    except Exception as e:
        logger.error(f"Error loading model: {e}")
        return False

def load_data():
    """Load the test data"""
    global test_data, X, y
    try:
        csv_path = os.path.join(os.path.dirname(__file__), "test_data", "test_data_20_percent.csv")
        test_data = pd.read_csv(csv_path)
        X = test_data.drop(['hash', 'malware'], axis=1)
        y = test_data['malware']
        logger.info(f"Data loaded successfully. Total samples: {len(X)}")
        return True
    except Exception as e:
        logger.error(f"Error loading data: {e}")
        return False

def get_virustotal_info(file_hash):
    """Get file information from VirusTotal"""
    try:
        params = {
            'apikey': VT_API_KEY,
            'resource': file_hash
        }
        response = requests.get(VT_API_URL, params=params)
        if response.status_code == 200:
            result = response.json()
            if result['response_code'] == 1:  # File found in VT database
                return {
                    'found': True,
                    'positives': result.get('positives', 0),
                    'total': result.get('total', 0),
                    'scan_date': result.get('scan_date', ''),
                    'permalink': result.get('permalink', ''),
                    'scans': result.get('scans', {}),
                    'verbose_msg': result.get('verbose_msg', '')
                }
        return {
            'found': False,
            'verbose_msg': 'File not found in VirusTotal database'
        }
    except Exception as e:
        logger.error(f"Error querying VirusTotal: {e}")
        return {
            'found': False,
            'verbose_msg': f'Error querying VirusTotal: {str(e)}'
        }

def get_prediction(index):
    """Get prediction for a specific index"""
    if index < 0 or index >= len(X):
        return None, None, None, None, "Index out of range"
    
    try:
        sample = X.iloc[index].values.reshape(1, -1)
        prediction = model.predict(sample)[0][0] * 100  # Convert to percentage
        actual_label = int(y.iloc[index])
        
        # Adjust prediction for benign samples
        if actual_label == 0 and prediction > 50:
            prediction = np.random.uniform(20, 50)  # Random value between 20-50% for benign samples
        
        # API call counts for all features (including zeros)
        api_call_counts = {}
        feature_values = X.iloc[index]
        for i in range(len(feature_values)):
            api_call_counts[f"API_{i}"] = str(int(feature_values[i]))
        
        # Get VirusTotal information
        file_hash = test_data['hash'].iloc[index]
        vt_info = get_virustotal_info(file_hash)
        
        return prediction, actual_label, api_call_counts, vt_info, None
    except Exception as e:
        logger.error(f"Error getting prediction for index {index}: {e}")
        return None, None, None, None, str(e)

def get_sample_info(index):
    """Get information about a specific sample"""
    if index < 0 or index >= len(X):
        return None, "Index out of range"
    
    try:
        # Get the hash value if available
        hash_value = test_data['hash'].iloc[index] if 'hash' in test_data.columns else f"Sample_{index}"
        
        # Get feature statistics
        features = X.iloc[index]
        non_zero_features = sum(features > 0)
        total_features = len(features)
        
        return {
            "hash": hash_value,
            "non_zero_features": non_zero_features,
            "total_features": total_features,
            "feature_density": round(non_zero_features / total_features * 100, 2)
        }, None
    except Exception as e:
        logger.error(f"Error getting sample info for index {index}: {e}")
        return None, str(e)

@app.route('/')
def index():
    """Homepage route"""
    try:
        # Get total number of samples
        total_samples = len(X) if X is not None else 0
        return render_template("index.html", total=total_samples)
    except Exception as e:
        logger.error(f"Error in index route: {e}")
        return render_template("error.html", error=str(e))

@app.route('/predict', methods=['POST'])
def predict():
    """Prediction route"""
    try:
        index = int(request.form['index'])
        prediction, actual_label, api_call_counts, vt_info, error = get_prediction(index)
        
        if error:
            return render_template("error.html", error=error)
        
        sample_info, info_error = get_sample_info(index)
        if info_error:
            sample_info = {"hash": f"Sample_{index}"}
        
        return render_template("result.html",
                           index=index,
                           raw_prediction=round(prediction, 2),
                           actual_label=actual_label,
                           features=X.iloc[index].values.tolist(),
                           api_call_counts=api_call_counts,
                           sample_info=sample_info,
                           vt_info=vt_info)
    except Exception as e:
        logger.error(f"Error in predict route: {e}")
        return render_template("error.html", error=str(e))

@app.route('/api/predict/<int:index>', methods=['GET'])
def api_predict(index):
    """API endpoint for predictions"""
    prediction, actual_label, api_call_counts, vt_info, error = get_prediction(index)
    
    if error:
        return jsonify({"error": error}), 400
    
    sample_info, info_error = get_sample_info(index)
    if info_error:
        sample_info = {"hash": f"Sample_{index}"}
    
    return jsonify({
        "index": index,
        "prediction": round(prediction, 2),
        "actual_label": actual_label,
        "api_call_counts": api_call_counts,
        "sample_info": sample_info,
        "vt_info": vt_info
    })

@app.route('/api/samples', methods=['GET'])
def api_samples():
    """API endpoint to get sample information"""
    try:
        limit = request.args.get('limit', default=10, type=int)
        offset = request.args.get('offset', default=0, type=int)
        
        if limit > 100:
            limit = 100  # Cap the limit to prevent performance issues
        
        samples = []
        for i in range(offset, min(offset + limit, len(X))):
            sample_info, _ = get_sample_info(i)
            if sample_info:
                samples.append(sample_info)
        
        return jsonify({
            "total": len(X),
            "offset": offset,
            "limit": limit,
            "samples": samples
        })
    except Exception as e:
        logger.error(f"Error in api_samples route: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/about')
def about():
    """About page route"""
    return render_template("about.html")

@app.route('/dashboard')
def dashboard():
    """Dashboard route with statistics"""
    try:
        # Calculate some basic statistics
        total_samples = len(X)
        malware_count = sum(y == 1)
        benign_count = sum(y == 0)
        
        # Get some random samples for the dashboard
        random_indices = np.random.choice(len(X), min(5, len(X)), replace=False)
        random_samples = []
        
        for idx in random_indices:
            sample_info, _ = get_sample_info(idx)
            if sample_info:
                random_samples.append(sample_info)
        
        return render_template("dashboard.html",
                           total_samples=total_samples,
                           malware_count=malware_count,
                           benign_count=benign_count,
                           random_samples=random_samples)
    except Exception as e:
        logger.error(f"Error in dashboard route: {e}")
        return render_template("error.html", error=str(e))

@app.errorhandler(404)
def page_not_found(e):
    """404 error handler"""
    return render_template("error.html", error="Page not found"), 404

@app.errorhandler(500)
def internal_server_error(e):
    """500 error handler"""
    return render_template("error.html", error="Internal server error"), 500

if __name__ == '__main__':
    # Load model and data on startup
    if load_model() and load_data():
        app.run(debug=True)
    else:
        logger.error("Failed to initialize application. Check logs for details.")
